{{- /*gotype: github.com/paynejacob/speakerbob/pkg/store/provider.resource */ -}}
package {{ .PackageName }}

import (
    "github.com/paynejacob/speakerbob/pkg/graph"
    "github.com/paynejacob/speakerbob/pkg/store"
    "github.com/vmihailenco/msgpack/v5"
    "sync"
    "fmt"
)

// DO NOT EDIT THIS CODE IS GENERATED

const {{ .Name }}ProviderKeyPrefix = "{{ .PackageName }}.{{ .Name }}"

type {{ .Name }}Provider struct {
    Store store.Store

    mu    sync.RWMutex
    cache map[string]*{{ .Name }}

    searchIndex *graph.Graph

    {{- range .LookupFields }}
    lookup{{ .Name }} map[{{ .Type }}]*{{ $.Name }}
    {{- end}}
}

func New{{ .Name }}Provider(s store.Store) *{{ .Name }}Provider {
    return &{{ .Name }}Provider{
        Store: s,
        mu: sync.RWMutex{},
        cache: map[string]*{{ .Name }}{},
        {{-  range .LookupFields }}
        lookup{{ .Name }}: map[{{ .Type }}]*{{ $.Name }}{},
        {{- end}}
        searchIndex: graph.NewGraph(),
    }
}

func (p *{{ .Name }}Provider) Get(k string) *{{ .Name }} {
    p.mu.RLock()
    defer p.mu.RUnlock()

    if o, ok := p.cache[k]; ok {
        return o
    }

    return &{{ .Name }}{}
}

func (p *{{ .Name }}Provider) List() []*{{ .Name }} {
    rval := make([]*{{ .Name }}, 0)

    p.mu.RLock()
    defer p.mu.RUnlock()

    for _, o := range p.cache {
        rval = append(rval, o)
    }

    return rval
}

func (p *{{ .Name }}Provider) Search(query string) []*{{ .Name }} {
    results := make([]*{{ .Name }}, 0)

    p.mu.RLock()
    defer p.mu.RUnlock()

    for _, keyBytes := range p.searchIndex.Search([]byte(query)) {
        results = append(results, p.cache[string(keyBytes)])
    }

    return results
}

func (p *{{ .Name }}Provider) Save(o *{{ .Name }}) error {
    p.mu.Lock()
    defer p.mu.Unlock()

    body, err := msgpack.Marshal(o)

    if err = p.Store.Save(p.GetKey(o), body); err != nil {
        return err
    }

    p.cache[o.{{ .KeyField }}] = o
    {{ range .SearchableFields }}
    p.searchIndex.Write(graph.Tokenize(o.{{ . }}), []byte(o.{{ $.KeyField }}))
    {{end}}
    {{ range .LookupFields }}
    {{if .IsArray }}
    for _, v := range o.{{ .Name }} {
        p.lookup{{.Name}}[v] = o
    }
    {{ else }}
    p.lookup{{.Name}}[o.{{ .Name }}] = o
    {{ end }}
    {{end}}

    return nil
}

func (p *{{ .Name }}Provider) Delete(o *{{ .Name }}) error {
    p.mu.Lock()
    defer p.mu.Unlock()

    if err := p.Store.Delete(p.GetKey(o)); err != nil {
        return err
    }

    o = p.Get(o.{{ .KeyField }})

    {{ range .LookupFields }}
    {{if .IsArray }}
    for _, v := range o.{{ .Name }} {
        delete(p.lookup{{.Name}}, v)
    }
    {{ else }}
    delete(p.lookup{{.Name}}, o.{{ .Name }})
    {{ end }}
    {{end}}

    delete(p.cache, o.{{ .KeyField }})
    p.searchIndex.Delete([]byte(o.{{ .KeyField }}))

    return nil
}

func (p *{{ .Name }}Provider) Initialize() error {
    p.mu.Lock()
    defer p.mu.Unlock()

    return p.Store.List([]byte({{ .Name }}ProviderKeyPrefix), func(bytes []byte) error {
        o := {{ .Name }}{}

        if err := msgpack.Unmarshal(bytes, &o); err != nil {
            return err
        }

        p.cache[o.{{ .KeyField }}] = &o
        {{ range .SearchableFields }}
        p.searchIndex.Write(graph.Tokenize(o.{{ . }}), []byte(o.{{ $.KeyField }}))
        {{end}}
        {{ range .LookupFields }}
        {{if .IsArray }}
        for _, v := range o.{{ .Name }} {
            p.lookup{{.Name}}[v] = &o
        }
        {{ else }}
        p.lookup{{.Name}}[o.{{ .Name }}] = &o
        {{ end }}
        {{end}}

        return nil
    })
}

{{ range .LookupFields }}
func (p *{{ $.Name }}Provider) GetBy{{ .Name }}(v {{ .Type }}) *{{ $.Name }} {
    p.mu.RLock()
    defer p.mu.RUnlock()

    if o, ok := p.lookup{{ .Name }}[v]; ok {
        return o
    }

    return &{{ $.Name }}{}
}
{{ end }}

func (p *{{ $.Name }}Provider) GetKey(o *{{ .Name }}) store.Key {
    return store.Key(fmt.Sprintf("%s:%s", {{ .Name }}ProviderKeyPrefix, o.{{ .KeyField }}))
}
